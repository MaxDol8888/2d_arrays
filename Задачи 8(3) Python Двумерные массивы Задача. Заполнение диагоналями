program FILLDIAG;
(* Заполнить двумерный массив 10х10 по диагоналям : *)
(*  1  2  4  7 11 ..             *)
(*  3  5  8 12   .               *)
(*  6  9 13    .  /              *)
(* 10 14        /     /          *)
(* 15         /     /            *)
(*          L     /              *)
(*              L             91 *)
(*                    .    92 95 *)
(*                  .   93 96 98 *)
(*                .. 94 97 99100 *)
(* Eugene V. Ogurtsov *)
(* 02.03.2000 *)

(* Variables definitions part *)
var
  Mas : array [1..10, 1..10] of Integer;
  k : Integer;    (* Номер текущей диагонали *)
  x, y : Integer; (* Координаты текущего элемента массива *)
  i : Integer;    (* Вставляемое число *)

(* Operators part *)
begin
  WriteLn;
  WriteLn('Заполнение массива по диагоналям');
  i := 1; (* Начинаем заполнять с 1 *)

  (* Заполнение лево-верхней половины *)
  for k := 1 to 10 do
  begin
    x := k; (* х-координата первого элемента к-ой диагонали *)
    y := 1; (* у-координата первого элемента к-ой диагонали *)
    (* Пока не кончилась диагональ, заполняем ее *)
    while x > 0 do
    begin
      Mas[x, y] := i;
      i := i + 1;
      x := x - 1; (* Смещаемся влево *)
      y := y + 1  (* и вниз *)
    end
  end;

  (* Заполнение право-нижней половины *)
  for k := 2 to 10 do
  begin
    x := 10; (* х-координата первого элемента к-ой диагонали *)
    y := k;  (* у-координата первого элемента к-ой диагонали *)
    (* Пока не кончилась диагональ, заполняем ее *)
    while y <= 10 do
    begin
      Mas[x, y] := i;
      i := i + 1;
      x := x - 1; (* Смещаемся влево *)
      y := y + 1  (* и вниз *)
    end
  end;

  (* Вывод содержимого массива на экран *)
  for y := 1 to 10 do
  begin
    (* Выводим все элементы одной строки (по 3 позиции на число) *)
    for x := 1 to 10 do
      Write(Mas[x, y] : 3);
    (* Переходим к следующей строке *)
    WriteLn
  end
end. (* End of operators part *)

(* End of 'FILLDIAG.PAS' file *)

http://www.school30.spb.ru/csd/ogt/samp/pas_task_021.htm


#include <iostream>
using namespace std;

int main() {
    int n, m, pos = 0, row = 0;
    cin >> n >> m;
    int a[n][m];

    // обработка
    int start_row = 0;
    int number = 1;
    for (int min_row = 0; min_row < n; min_row++) {
        if (min_row > 0) start_row = pos - 1;
        else start_row = 0;
        for (pos = start_row; pos < m; pos++) {
            row = min_row;
            for (int col = pos; col >= 0; col--) {
                if (row < n) {
                    a[row][col] = number;
                    number++;
                    row++;
                }
                else break;
            }
        }
    }
    // вывод
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (a[i][j] % 10 == a[i][j]) cout << "   ";
            else if (a[i][j] % 100 == a[i][j]) cout << "  ";
            else if (a[i][j] % 1000 == a[i][j]) cout << " ";
            cout << a[i][j];
        }
        cout << endl;
    }
    return 0;
}


ИМХО решению 11 задачи долеко до идеала. 
Вот на пример мое:
#include <iostream>
using namespace std;
int main() {
int n, m, a[100][100], k = 1;
cin >> n >> m;
for(int t = 0; t < m + n - 1; t++)
for(int i = 0; i < n; i++)
for(int j = 0; j < m; j++)
if(i + j == t){
a[i][j] = k;
k++;}
for(int i = 0; i < n; i++){
for(int j = 0; j < m; j++){
if (a[i][j] % 10 == a[i][j]) cout << " ";
else if (a[i][j] % 100 == a[i][j]) cout << " ";
else if (a[i][j] % 1000 == a[i][j]) cout << " ";
cout << a[i][j];
}
cout << endl;
}
return 0;
}


http://practice.keyfire.ru/blog/dvuhmernye-massivy-na-c/



http://cppstudio.com/post/4991/ - Заполнить двумерный массив зигзагом по диагонали
