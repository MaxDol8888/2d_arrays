program FILLDIAG;
(* Заполнить двумерный массив 10х10 по диагоналям : *)
(*  1  2  4  7 11 ..             *)
(*  3  5  8 12   .               *)
(*  6  9 13    .  /              *)
(* 10 14        /     /          *)
(* 15         /     /            *)
(*          L     /              *)
(*              L             91 *)
(*                    .    92 95 *)
(*                  .   93 96 98 *)
(*                .. 94 97 99100 *)
(* Eugene V. Ogurtsov *)
(* 02.03.2000 *)

(* Variables definitions part *)
var
  Mas : array [1..10, 1..10] of Integer;
  k : Integer;    (* Номер текущей диагонали *)
  x, y : Integer; (* Координаты текущего элемента массива *)
  i : Integer;    (* Вставляемое число *)

(* Operators part *)
begin
  WriteLn;
  WriteLn('Заполнение массива по диагоналям');
  i := 1; (* Начинаем заполнять с 1 *)

  (* Заполнение лево-верхней половины *)
  for k := 1 to 10 do
  begin
    x := k; (* х-координата первого элемента к-ой диагонали *)
    y := 1; (* у-координата первого элемента к-ой диагонали *)
    (* Пока не кончилась диагональ, заполняем ее *)
    while x > 0 do
    begin
      Mas[x, y] := i;
      i := i + 1;
      x := x - 1; (* Смещаемся влево *)
      y := y + 1  (* и вниз *)
    end
  end;

  (* Заполнение право-нижней половины *)
  for k := 2 to 10 do
  begin
    x := 10; (* х-координата первого элемента к-ой диагонали *)
    y := k;  (* у-координата первого элемента к-ой диагонали *)
    (* Пока не кончилась диагональ, заполняем ее *)
    while y <= 10 do
    begin
      Mas[x, y] := i;
      i := i + 1;
      x := x - 1; (* Смещаемся влево *)
      y := y + 1  (* и вниз *)
    end
  end;

  (* Вывод содержимого массива на экран *)
  for y := 1 to 10 do
  begin
    (* Выводим все элементы одной строки (по 3 позиции на число) *)
    for x := 1 to 10 do
      Write(Mas[x, y] : 3);
    (* Переходим к следующей строке *)
    WriteLn
  end
end. (* End of operators part *)

(* End of 'FILLDIAG.PAS' file *)

http://www.school30.spb.ru/csd/ogt/samp/pas_task_021.htm


#include <iostream>
using namespace std;

int main() {
    int n, m, pos = 0, row = 0;
    cin >> n >> m;
    int a[n][m];

    // обработка
    int start_row = 0;
    int number = 1;
    for (int min_row = 0; min_row < n; min_row++) {
        if (min_row > 0) start_row = pos - 1;
        else start_row = 0;
        for (pos = start_row; pos < m; pos++) {
            row = min_row;
            for (int col = pos; col >= 0; col--) {
                if (row < n) {
                    a[row][col] = number;
                    number++;
                    row++;
                }
                else break;
            }
        }
    }
    // вывод
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (a[i][j] % 10 == a[i][j]) cout << "   ";
            else if (a[i][j] % 100 == a[i][j]) cout << "  ";
            else if (a[i][j] % 1000 == a[i][j]) cout << " ";
            cout << a[i][j];
        }
        cout << endl;
    }
    return 0;
}


ИМХО решению 11 задачи долеко до идеала. 
Вот на пример мое:
#include <iostream>
using namespace std;
int main() {
int n, m, a[100][100], k = 1;
cin >> n >> m;
for(int t = 0; t < m + n - 1; t++)
for(int i = 0; i < n; i++)
for(int j = 0; j < m; j++)
if(i + j == t){
a[i][j] = k;
k++;}
for(int i = 0; i < n; i++){
for(int j = 0; j < m; j++){
if (a[i][j] % 10 == a[i][j]) cout << " ";
else if (a[i][j] % 100 == a[i][j]) cout << " ";
else if (a[i][j] % 1000 == a[i][j]) cout << " ";
cout << a[i][j];
}
cout << endl;
}
return 0;
}


http://practice.keyfire.ru/blog/dvuhmernye-massivy-na-c/


Заполнить двумерный массив зигзагом по диагонали

/*    1  3  4 10 11
      2  5  9 12 19
      6  8 13 18 20
      7 14 17 21 24
     15 16 22 23 25  */
     
   1    3    4   10   11   21   22   36   37   55 
   2    5    9   12   20   23   35   38   54   56 
   6    8   13   19   24   34   39   53   57   72 
   7   14   18   25   33   40   52   58   71   73 
  15   17   26   32   41   51   59   70   74   85 
  16   27   31   42   50   60   69   75   84   86 
  28   30   43   49   61   68   76   83   87   94 
  29   44   48   62   67   77   82   88   93   95 
  45   47   63   66   78   81   89   92   96   99 
  46   64   65   79   80   90   91   97   98  100


По условию программы, массив — квадратная матрица, то есть имеет одинаковое количество строк и столбцов. 
Возможно это упростит задачу. Дам подсказку — рассмотрите массив как область в квадратной системе координат. 
То есть, для перемещения по элементам матрицы, мы условно будем пользоваться x и y координаты.
х-координата — переменная, которая будет отвечать за перемещение по горизонтали (по столбцам), 
y-координата — отвечает за перемещение по вертикали (по строкам).

Мой способ решения состоит из двух этапов:

заполнение первой половины массива;
заполнение второй половины;
Например,

/*  заполнение первой половины массива (строки 16 - 44)
      1  3  4 10 11
      2  5  9 12  0
      6  8 13  0  0
      7 14  0  0  0
     15  0  0  0  0  */
     
 ну и конечно же, заполнение остальной части массива (строки 48 — 76):
 
 /*    0  0  0  0  0
      0  0  0  0 19
      0  0  0 18 20
      0  0 17 21 24
      0 16 22 23 25  */
      
 Каждая часть массива заполняется отдельным циклом for, в котором перебор идет по диагоналям. 
Заметьте, что каждый новый столбец — это начало новой диагонали. Поэтому циклы for будут перебирать столбцы, предполагая, 
что это диагонали. То есть, каждая пройденная итерация цикла for — это заполненная диагональ.

Исходный код этой программы был бы в два раза меньше, но дело в том, что нужно организовать зигзагообразное заполнение.
 И поэтому, Для каждой заполняемой половины массива, нужно рассмотреть два случая:

заполнение диагонали снизу-вверх (для первой части — строки: 33 -42, второй части массива — строки: 65 — 74)
заполнение диагонали сверху-вниз (для первой части — строки: 20 -29, второй части массива — строки: 52 — 62)
И чтобы два способа заполнения диагоналей чередовались, мы делаем проверку в строке 18, 
для заполнения первой половины массива и в строке 50, для заполнения второй половины массива.

Непосредственно в циклах while выполняется заполнение диагоналей. В коде оставил много комментариев, надеюсь объяснил понятно.  

#include <iostream>
#include <iomanip>
using namespace std;
 
int main()
{
    const int colum = 10; // количество столбцов массива
    const int row   = 10; // количество строк массива
    int array[100][100];
 
    int x, y,  // Координаты текущего элемента массива
        value = 1; // значение, которым заполняется массив
 
    // зполнение первой половины массива по диагонали, зигзагом, начиная
    // слева и сверху, заканчивая  побочной диагональю
    for (int diag = 0; diag < colum; diag++) // выполняем проход по диагоналям
    {
        if (diag % 2 == 0) // по четным диагоналям
        {
            x = 0; // х-координата первого лемента массива на диагонали - diag
            y = diag; // у-координата элемента массива на диагонали - diag
 
            while (y >= 0) // пока y-координата находится в верхней части диагонали
            {
                array[x][y] = value; // записать значение в массив
                value++;
                x++;     // по горизонтали, смещаемся влево
                y--;    // по вертикали, смещаемся вниз
            }
        }
        else // по нечетным диагоналям
        {
            x = diag; // х-координата элемента массива на диагонали - diag
            y = 0; // у-координата первого элемента массива на диагонали - diag
 
            while (x >= 0) // пока x-координата находится в левой части диагонали
            {
                array[x][y] = value; // записать значение в массив
                value++;
                x -= 1;  // по горизонтали, смещаемся вправо
                y +=  1; // по вертикали, смещаемся вверх
            }
        }
    } // конец for
 
    // заполнение второй половины массива по диагонали, зигзагом, начиная
    // слева и сверху, заканчивая  последним элементом массива
    for (int diag = 1; diag < colum; diag++)
    {
        if (diag % 2 == 0) // по четным диагоналям
        {
            x = 9; // х-координата первого элемента массива на диагонали - diag
            y = diag;  // у-координата элемента массива на диагонали - diag
 
            while (y <= 9) // Пока не кончилась диагональ
            {
                array[x][y] = value;
                value++;
                x--; // по горизонтали, смещаемся влево
                y++; // по вертикали, смещаемся вниз
            }
        }
        else // по не четным диагоналям
        {
            x = diag; // х-координата первого элемента к-ой диагонали
            y = 9;  // у-координата первого элемента к-ой диагонали
 
            while (x <= 9) // Пока не кончилась диагональ
            {
                array[x][y] = value;
                value++;
                x++; // по горизонтали, смещаемся вправо
                y--; // по вертикали, смещаемся вверх
            }
        } // конец if-else
    } // конец цикла for (заполнение второй половины массива)
 
    // вывод масиива на экран
    for (int ix = 0; ix < row; ix++)
    {
        for (int jx = 0; jx < colum; jx++)
            cout << setw(4) << array[ix][jx] << " ";
        cout << endl;
    }
 
    return 0;
}

Скорее всего мой код можно уменьшить, приблизительно в 2 раза, но у меня с ходу не получилось это сделать.
Поэтому оставил все так. Если у вас получится уменьшить исходный код или найти другое решение, поделитесь с читателями нашего сайта.
Ах да, я забыл реализовать в данной программе ввод размера массива, но я думаю это у вас получится и без меня.
Пример работы программы:

   1    3    4   10   11   21   22   36   37   55 
   2    5    9   12   20   23   35   38   54   56 
   6    8   13   19   24   34   39   53   57   72 
   7   14   18   25   33   40   52   58   71   73 
  15   17   26   32   41   51   59   70   74   85 
  16   27   31   42   50   60   69   75   84   86 
  28   30   43   49   61   68   76   83   87   94 
  29   44   48   62   67   77   82   88   93   95 
  45   47   63   66   78   81   89   92   96   99 
  46   64   65   79   80   90   91   97   98  100

http://cppstudio.com/post/4991/
